# phpMyAdmin MySQL-Dump
# version 2.3.0-rc3
# http://phpwizard.net/phpMyAdmin/
# http://www.phpmyadmin.net/ (download page)
#
# Host: localhost
# Generation Time: Aug 02, 2003 at 04:36 AM
# Server version: 4.00.00
# PHP Version: 4.3.0
# Database : `sitepoint`
# --------------------------------------------------------

#
# Table structure for table `articles`
#

CREATE TABLE articles (
  article_id int(11) NOT NULL auto_increment,
  title varchar(255) NOT NULL default '',
  intro text NOT NULL,
  body text NOT NULL,
  author varchar(255) NOT NULL default '',
  published varchar(11) default NULL,
  public enum('0','1') NOT NULL default '0',
  PRIMARY KEY  (article_id),
  FULLTEXT KEY art_search (title,body,author)
) TYPE=MyISAM;

#
# Dumping data for table `articles`
#

INSERT INTO articles VALUES (1, 'Build your own Database Driven Website using PHP & MySQL', 'On the Web today, content is king. Once you\'ve mastered HTML and learned a few neat tricks in JavaScript and Dynamic HTML, you can probably build a pretty impressive-looking Web site design. But then comes the time to fill that fancy page layout with some real information. Any site that successfully attracts repeat visitors has to have fresh and constantly-updated content. In the world of traditional site building, that means HTML files -- and lots of \'em.', '<p>The problem is that, more often than not, the people who provide the content for a site are not the same people who handle its design. Oftentimes, the content provider doesn\'t even know HTML. How, then, is the content to get from the provider onto the Web site? Not every company can afford to staff a full-time Webmaster, and most Webmasters have better things to do than copying Word files into HTML templates anyway.</p>\r\n\r\n<p>Maintenance of a content-driven site can be a real pain, too. Many sites (perhaps yours?) feel locked into a dry, outdated design because rewriting those hundreds of HTML files to reflect a new design would take forever. Server-side includes (SSI\'s) can help alleviate the burden a little, but you still end up with hundreds of files that need to be maintained should you wish to make a fundamental change to your site.</p>\r\n\r\n<p>The solution to these headaches is database-driven site design. By achieving complete separation between your site\'s design and the content you want to present, you can work with each without disturbing the other. Instead of writing an HTML file for every page of your site, you only need to write a page for each kind of information you want to be able to present. Instead of endlessly pasting new content into your tired page layouts, create a simple content management system that allows the writers to post new content themselves without a lick of HTML!</p>\r\n\r\n<p>In this series of articles, I\'ll provide you with a hands-on look at what\'s involved in building a database-driven Web site. We\'ll use two tools for this, both of which may be new to you: the PHP scripting language and the MySQL relational database management system. If your Web host provides PHP and MySQL support, you\'re in great shape. If not, we\'ll be looking at the set-up procedures under Linux and Windows, so don\'t sweat it.</p>\r\n\r\n\r\n\r\n<h5>Who Should Read this Series</h5>\r\n\r\n\r\n\r\n<p>These articles are aimed at intermediate or advanced Web designers looking to make the leap into server-side programming. You\'ll be expected to be comfortable with simple HTML, as I\'ll be making use of it without much in the way of explanation. A teensy bit of JavaScript may serve us well at some point as well, but I\'ll be sure to keep it simple for the uninitiated.</p>\r\n\r\n<p>By the end of this series, you can expect to have a grasp of what\'s involved in setting up and building a database-driven Web site. If you follow the examples, you\'ll also learn the basics of PHP (a server-side scripting language that allows you to do a lot more than access a database easily) and Structured Query Language (SQL -- the standard language for interacting with relational databases) as supported by MySQL, one of the most popular free database engines available today. Most importantly, you\'ll come away with everything you need to get started on your very own database-driven site in no time!</p>\r\n\r\n<h5>What\'s in this Series</h5>\r\n\r\n\r\n\r\n<p>This series comprises the following 4 chapters. Read them in order from beginning to end to gain a complete understanding of the subject, or skip around if you need a refresher on a particular topic.</p>\r\n\r\n<p><a class="sublink" href="http://www.webmasterbase.com/article.php/525">Chapter 1: Installation</a></p>\r\n\r\n<p>Before you can start building your database-driven Web presence, you must first ensure that you have the right tools for the job. In this first chapter, I\'ll tell you where to obtain the two essential components you\'ll need: the PHP scripting language and the MySQL database management system. I\'ll step you through the set-up procedures on both Windows and Linux, and show you how to test that PHP is operational on your Web server.</p>\r\n\r\n<p><a class="sublink" href="http://www.webmasterbase.com/article.php/527">Chapter 2: Getting Started with MySQL</a></p>\r\n\r\n<p>Although I\'m sure you\'ll be anxious to get started building dynamic Web pages, I\'ll begin with an introduction to databases in general, and the MySQL relational database management system in particular. If you\'ve never worked with a relational database before, this should definitely be an enlightening chapter that will whet your appetite for things to come! In the process, we\'ll build up a simple database to be used in later chapters.</p>\r\n\r\n<p><a class="sublink" href="http://www.webmasterbase.com/article.php/528">Chapter 3: Getting Started with PHP</a></p>\r\n\r\n<p>Here\'s where the fun really starts. In this chapter, I\'ll introduce you to the PHP scripting language, which can be used to easily build dynamic Web pages that present up-to-the-moment information to your visitors. Readers with previous programming experience will probably be able to get away with a quick skim of this chapter, as I explain the essentials of the language from the ground up. This is a must-read chapter for beginners, however, as the rest of this series relies heavily on the basic concepts presented here.</p>\r\n\r\n<p><a class="sublink" href="http://www.webmasterbase.com/article.php/530">Chapter 4: Publishing MySQL Data on the Web</a></p>\r\n\r\n<p>In this chapter we bring together PHP and MySQL, which you\'ll have seen separately in the previous two chapters, to create some of your first database-driven Web pages. We\'ll explore the basic techniques of using PHP to retrieve information from a database and display it on the Web in real time. I\'ll also show you how to use PHP to create Web-based forms for adding new entries to, and modifying existing information in, a MySQL database on-the-fly.</p>\r\n\r\n<h5>The Book</h5>\r\n\r\n\r\n\r\n<p>The four chapters in this series are actually only the first part of a book. <a rel=\'external\' class="sublink" href="http://sitepoint.com/books/?bookid=in228b"><strong>Build Your Own Database Driven Website Using PHP &amp; MySQL</strong></a> contains not only the four chapters above, but eight more chapters that cover advanced database concepts, the design of a complete content management system, MySQL server administration, and much, much more! The book also includes a complete set of appendices to make it the ideal desk reference for PHP and MySQL Web development. For more information, see the <a class="sublink" href="http://sitepoint.com/books/?bookid=in228b">book page</a>.</p>', 'Kevin Yank', '1033423200', '1');
INSERT INTO articles VALUES (3, 'Write Secure Scripts with PHP 4.2!', 'For the longest time, one of the biggest selling points of PHP as a server-side scripting language was that values submitted from a form were automatically created as global variables for you. As of PHP 4.1, the makers of PHP recommended an alternate means of accessing submitted data. In PHP 4.2, they switched off the old way of doing things! As I\'ll explain in this article, these changes have been made in the name of security. Together, we\'ll explore the new features of PHP for handling form submissions and other data, and how they can be used to write more secure scripts.', '<h5>What\'s wrong with this picture?</h5>\r\n\r\n<p>Consider the following PHP script, which grants access to a Web page only if the correct username and password are entered:</p>\r\n\r\n<p><code>&lt;?php <br />\r\n &nbsp;// Check the username and password <br />\r\n &nbsp;if ($username == \'kevin\' and $password == \'secret\') <br />\r\n &nbsp; &nbsp;$authorized = true; <br />\r\n?&gt; <br />\r\n&lt;?php if (!$authorized): ?&gt; <br />\r\n &nbsp;&lt;!-- Unauthorized users are prompted for their credentials --&gt; <br />\r\n &nbsp;&lt;p&gt;Please enter your username and password:&lt;/p&gt; <br />\r\n &nbsp;&lt;form action=&quot;&lt;?=$PHP_SELF?&gt;&quot; method=&quot;POST&quot;&gt; <br />\r\n &nbsp; &nbsp;&lt;p&gt;Username: &lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt;&lt;br /&gt; <br />\r\n &nbsp; &nbsp; &nbsp; Password: &lt;input type=&quot;password&quot; name=&quot;password&quot; /&gt;&lt;br /&gt; <br />\r\n &nbsp; &nbsp; &nbsp; &lt;input type=&quot;submit&quot; /&gt;&lt;/p&gt; <br />\r\n &nbsp;&lt;/form&gt; <br />\r\n&lt;?php else: ?&gt; <br />\r\n &nbsp;&lt;!-- Super-Secret HTML content goes here --&gt; <br />\r\n&lt;?php endif; ?&gt;</code></p>\r\n\r\n<p>Okay, I\'m sure about half the readers in the audience just rolled their eyes and said &quot;That\'s so stupid -- I would never make a mistake like that!&quot; But I guarantee that a good number of you are thinking &quot;Hey, that\'s not bad. I should write that down!&quot; And of course there\'s always the rather confused minority (&quot;What\'s PHP?&quot;). PHP was designed as a &quot;nice and easy&quot; scripting language that beginners can start to use in minutes; it should also protect those beginners from making scary mistakes like the one above.</p>\r\n\r\n<p>For the record, the problem with the above script is that you can easily gain access to it without supplying the correct username and password. Simply type the address of the page into your browser with <code>?authorized=1</code> tacked on the end. Since PHP automatically creates a variable for every value submitted -- either from a form post, the URL query string, or a cookie -- this sets <code>$authorized</code> to 1 in the script and plops an unauthorized user right in front of the Colonel\'s secret recipe (apologies to the non-junk food eating readers who will not get that joke).</p>\r\n\r\n<p>So, easy fix, right? Just set <code>$authorized</code> to false by default at the top of the script. The problem here is that a fix shouldn\'t have been necessary at all! <code>$authorized</code> is a variable created and used entirely within the script; why should the developer have to worry about protecting every single one of his or her variables from being overridden by values submitted by malicious users?</p>\r\n\r\n\r\n\r\n<h5>How does PHP 4.2 change things?</h5>\r\n\r\n\r\n\r\n<p>As of PHP 4.2, a fresh PHP installation has the <code>register_globals</code> option turned off by default, so EGPCS values (EGPCS is short for Environment, Get, Post, Cookies, Server -- the full range of external variable sources in PHP) are not created as global variables. Yes, this option can still be turned on manually, but the PHP team would prefer it if you didn\'t. To comply with their wishes, you\'ll need to use an alternate method to get at these values.</p>\r\n\r\n<p>Beginning with PHP 4.1, EGPCS values are now available in a set of special arrays:</p>\r\n\r\n<p><ul>\r\n	<li /><code>$_ENV</code> -- Contains system environment variables </li>\r\n	<li /><code>$_GET</code> -- Contains variables in the query string, including from GET forms</li>\r\n	<li /><code>$_POST</code> -- Contains variables submitted from POST forms</li>\r\n	<li /><code>$_COOKIE</code> -- Contains all cookie variables</li>\r\n	<li /><code>$_SERVER</code> -- Contains server variables, such as <code>HTTP_USER_AGENT</code></li>\r\n	<li /><code>$_REQUEST</code> -- Contains everything in <code>$_GET</code>, <code>$_POST</code>, and <code>$_COOKIE</code></li>\r\n	<li /><code>$_SESSION</code> -- Contains all registered session variables</li>\r\n</ul>\r\n</p>\r\n\r\n<p>Prior to PHP 4.1, developers who worked with <code>register_globals</code> turned off (this was also considered a good way to boost PHP performance a little) accessed these values using cumbersome arrays like <code>$HTTP_GET_VARS</code>. These new variable names are not only shorter, but they have some nice new features as well.</p>\r\n\r\n<p>First, let\'s re-write the broken script from the previous section for use under PHP 4.2 (i.e. with <code>register_globals</code> turned off):</p>\r\n\r\n<p><code>&lt;?php <br />\r\n &nbsp;$username = $_REQUEST[\'username\']; <br />\r\n &nbsp;$password = $_REQUEST[\'password\']; <br />\r\n &nbsp;$PHP_SELF = $_SERVER[\'PHP_SELF\']; <br />\r\n <br />\r\n &nbsp;// Check the username and password <br />\r\n &nbsp;if ($username == \'kevin\' and $password == \'secret\') <br />\r\n &nbsp; &nbsp;$authorized = true; <br />\r\n?&gt; <br />\r\n&lt;?php if (!$authorized): ?&gt; <br />\r\n &nbsp;&lt;!-- Unauthorized users are prompted for their credentials --&gt; <br />\r\n &nbsp;&lt;p&gt;Please enter your username and password:&lt;/p&gt; <br />\r\n &nbsp;&lt;form action=&quot;&lt;?=$PHP_SELF?&gt;&quot; method=&quot;POST&quot;&gt; <br />\r\n &nbsp; &nbsp;&lt;p&gt;Username: &lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt;&lt;br /&gt; <br />\r\n &nbsp; &nbsp; &nbsp; Password: &lt;input type=&quot;password&quot; name=&quot;password&quot; /&gt;&lt;br /&gt; <br />\r\n &nbsp; &nbsp; &nbsp; &lt;input type=&quot;submit&quot; /&gt;&lt;/p&gt; <br />\r\n &nbsp;&lt;/form&gt; <br />\r\n&lt;?php else: ?&gt; <br />\r\n &nbsp;&lt;!-- Super-Secret HTML content goes here --&gt; <br />\r\n&lt;?php endif; ?&gt;</code></p>\r\n\r\n<p>As you can see, all I had to do was add three lines to the top of the script:</p>\r\n\r\n<p><code> &nbsp;$username = $_REQUEST[\'username\']; <br />\r\n &nbsp;$password = $_REQUEST[\'password\']; <br />\r\n &nbsp;$PHP_SELF = $_SERVER\'[\'PHP_SELF\'];</code></p>\r\n\r\n<p>Since we\'re expecting the username and password to be submitted by the user, we grab these values out of the <code>$_REQUEST</code> array. Using this array allows users to pass in the values by any means at their disposal: through the URL query string (e.g. to allow users to create a bookmark that enters their credentials automatically for them), by a form submission, or as a cookie. If you would prefer to limit the methods by which they can submit their credentials to form submissions only (or more precisely, HTTP POST requests, which can be simulated without a form submission if push comes to shove), you could use the <code>$_POST</code> array instead:</p>\r\n\r\n<p><code> &nbsp;$username = $_POST[\'username\']; <br />\r\n &nbsp;$password = $_POST[\'password\']; <br />\r\n &nbsp;$PHP_SELF = $_SERVER[\'PHP_SELF\'];</code></p>\r\n\r\n<p>We also fetch the commonly-used <code>PHP_SELF</code> variable out of the array of server variables; like the form variables, it isn\'t created automatically with <code>register_globals</code> disabled. Since it\'s only used once in the script, you\'ll probably prefer just referencing it directly in your form code:</p>\r\n\r\n<p><code> &nbsp;&lt;form action=&quot;&lt;?=$_SERVER[\'PHP_SELF\']?&gt;&quot; method=&quot;POST&quot;&gt;</code></p>\r\n\r\n<p>Other than \'allowing in\' these three variables, the script hasn\'t changed at all. Turning <code>register_globals</code> off simply forces the developer to be aware of data that comes in from outside (untrusted) sources.</p>\r\n\r\n<p><strong>Note for the Nitpickers:</strong> The default <code>error_reporting</code> setting of PHP is still <code>E_ALL &amp; ~E_NOTICE</code>, so if the \'username\' and \'password\' values haven\'t been submitted, attempting to pull them out of the <code>$_REQUEST</code> or <code>$_POST</code> array will not produce an error message. If you\'re using a stricter level of error checking on your PHP setup, you\'ll need to add a little more code to check if these variables are set first.</p>\r\n\r\n\r\n\r\n<h5>But doesn\'t that mean more typing?</h5>\r\n\r\n\r\n\r\n<p>Yes, in simple scripts like the one above, the new way of doing things in PHP 4.2 does often require more typing. But hey, look on the bright side -- you could start charging by the keystroke!</p>\r\n\r\n<p>Seriously though, the makers of PHP are not entirely insensitive to your pain (I have a half brother who suffers from repetitive stress injuries). A special feature of these new arrays is that, unlike all other PHP variables, they are totally global. How does this help you? Let\'s extend our example a little to see.</p>\r\n\r\n<p>To allow for multiple pages on the site to require a username/password combination to be viewed, we\'ll move our authorization code into an include file (<code>protectme.php</code>) as follows:</p>\r\n\r\n<p><code>&lt;?php /* protectme.php */ <br />\r\n <br />\r\n &nbsp;function authorize_user($authuser, $authpass) <br />\r\n &nbsp;{ <br />\r\n &nbsp; &nbsp;$username = $_POST[\'username\']; <br />\r\n &nbsp; &nbsp;$password = $_POST[\'password\']; <br />\r\n <br />\r\n &nbsp; &nbsp;// Check the username and password <br />\r\n &nbsp; &nbsp;if ($username != $authuser or $password != $authpass): <br />\r\n &nbsp; &nbsp; &nbsp;?&gt; <br />\r\n &nbsp; &nbsp; &nbsp;&lt;!-- Unauthorized users are prompted for their credentials --&gt; <br />\r\n &nbsp; &nbsp; &nbsp;&lt;p&gt;Please enter your username and password:&lt;/p&gt; <br />\r\n &nbsp; &nbsp; &nbsp;&lt;form action=&quot;&lt;?=$_SERVER[\'PHP_SELF\']?&gt;&quot; method=&quot;POST&quot;&gt; <br />\r\n &nbsp; &nbsp; &nbsp; &nbsp;&lt;p&gt;Username: &lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt;&lt;br /&gt; <br />\r\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Password: &lt;input type=&quot;password&quot; name=&quot;password&quot; /&gt;&lt;br /&gt; <br />\r\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;input type=&quot;submit&quot; /&gt;&lt;/p&gt; <br />\r\n &nbsp; &nbsp; &nbsp;&lt;/form&gt; <br />\r\n &nbsp; &nbsp; &nbsp;&lt;?php <br />\r\n &nbsp; &nbsp; &nbsp;exit(); <br />\r\n &nbsp; &nbsp;endif; <br />\r\n &nbsp;} <br />\r\n?&gt;</code></p>\r\n\r\n<p>Now, our protected page looks like this:</p>\r\n\r\n<p><code>&lt;?php <br />\r\n &nbsp;require(\'protectme.php\'); <br />\r\n &nbsp;authorize_user(\'kevin\',\'secret\'); <br />\r\n?&gt; <br />\r\n&lt;!-- Super-Secret HTML content goes here --&gt;</code></p>\r\n\r\n<p>Nice and simple, right? Now here\'s a challenge for the especially eagle-eyed and experienced -- what\'s missing from the <code>authorize_user</code> function?</p>\r\n\r\n<p>What\'s missing is the declaration of <code>$_POST</code> inside the function to bring it in from the global scope! In PHP 4.0, with <code>register_globals</code> turned on, you\'d have had add a line of code to get access to the <code>$username</code> and <code>$password</code> variables inside the function:</p>\r\n\r\n<p><code> &nbsp;function authorize_user($authuser, $authpass) <br />\r\n &nbsp;{ <br />\r\n &nbsp; &nbsp;global $username, $password; <br />\r\n <br />\r\n &nbsp; &nbsp;...</code></p>\r\n\r\n<p>In PHP, unlike in other languages with similar syntax, variables outside a function are not automatically available inside the function. You need to specifically bring them in with the <code>global</code> line demonstrated above.</p>\r\n\r\n<p>With <code>register_globals</code> turned off in PHP 4.0 to improve security, you would use the <code>$HTTP_POST_VARS</code> array to obtain the values submitted from your form, but you would still have had to import that array from the global scope:</p>\r\n\r\n<p><code> &nbsp;function authorize_user($authuser, $authpass) <br />\r\n &nbsp;{ <br />\r\n &nbsp; &nbsp;global $HTTP_POST_VARS; <br />\r\n <br />\r\n &nbsp; &nbsp;$username = $HTTP_POST_VARS[\'username\']; <br />\r\n &nbsp; &nbsp;$password = $HTTP_POST_VARS[\'password\'];</code></p>\r\n\r\n<p>But in PHP 4.1 or later, the special <code>$_POST</code> variable (and the rest of the special variables listed in the previous section) are always available in all scopes. This is why the <code>$_POST</code> variable didn\'t need to be declared <code>global</code> at the top of the function:</p>\r\n\r\n<p><code> &nbsp;function authorize_user($authuser, $authpass) <br />\r\n &nbsp;{ <br />\r\n &nbsp; &nbsp;$username = $_POST[\'username\']; <br />\r\n &nbsp; &nbsp;$password = $_POST[\'password\'];</code></p>\r\n\r\n\r\n\r\n<h5>How does this affect sessions?</h5>\r\n\r\n\r\n\r\n<p>The introduction of the special <code>$_SESSION</code> array actually helps to simplify session code. Instead of registering global variables as session variables and then having to keep track of which variables are registered when, simply refer to all your session variables as <code>$_SESSION[\'varname\']</code>.</p>\r\n\r\n<p>Let\'s consider another authorization example. This time, it will use sessions to mark a user as authorized for the remainder of his or her stay on your site. First, the PHP 4.0 version (with <code>register_globals</code> enabled):</p>\r\n\r\n<p><code>&lt;?php <br />\r\n &nbsp;session_start(); <br />\r\n <br />\r\n &nbsp;if ($username == \'kevin\' and $password == \'secret\') <br />\r\n &nbsp;{ <br />\r\n &nbsp; &nbsp;$authorized = true; <br />\r\n &nbsp; &nbsp;session_register(\'authorized\'); <br />\r\n &nbsp;} <br />\r\n?&gt; <br />\r\n&lt;?php if (!$authorized): ?&gt; <br />\r\n &nbsp;&lt;!-- Display HTML Form prompting user to log in --&gt; <br />\r\n&lt;?php else: ?&gt; <br />\r\n &nbsp;&lt;!-- Super-secret HTML content goes here --&gt; <br />\r\n&lt;?php endif; ?&gt;</code></p>\r\n\r\n<p>Now, spot the security hole. As before, adding <code>?authorized=1</code> to the end of the URL bypasses the security measures and grants access to the page contents. The developer probably thought of <code>$authorized</code> as a session variable, and missed the fact that the same variable could easily be set by user input.</p>\r\n\r\n<p>Here\'s how the script looks when we add our special arrays (PHP 4.1) and switch off <code>register_globals</code> (PHP 4.2):</p>\r\n\r\n<p><code>&lt;?php <br />\r\n &nbsp;session_start(); <br />\r\n <br />\r\n &nbsp;if ($_POST[\'username\'] == \'kevin\' and <br />\r\n &nbsp; &nbsp; &nbsp;$_POST[\'password\'] == \'secret\') <br />\r\n &nbsp; &nbsp;$_SESSION[\'authorized\'] = true; <br />\r\n?&gt; <br />\r\n&lt;?php if (!$_SESSION[\'authorized\']): ?&gt; <br />\r\n &nbsp;&lt;!-- Display HTML Form prompting user to log in --&gt; <br />\r\n&lt;?php else: ?&gt; <br />\r\n &nbsp;&lt;!-- Super-secret HTML content goes here --&gt; <br />\r\n&lt;?php endif; ?&gt;</code></p>\r\n\r\n<p>See? Much more straightforward! Instead of registering a normal variable as a session variable, we set the session variable (in the <code>$_SESSION</code> array) directly, and then use it the same way. There\'s no more confusion as to which variables are session variables and you\'ll notice the code is slightly shorter too!</p>\r\n\r\n<h5>Summary</h5>\r\n\r\n\r\n\r\n<p>In this article I explained the reasoning behind recent changes to the PHP scripting language. In PHP 4.1, a set of special arrays were added to the language to access external data values. These arrays are available in any scope to make external data access a more convenient. In PHP 4.2, <code>register_globals</code> was turned off by default to encourage migration to the new arrays and to reduce the tendency of inexperienced developers to write insecure PHP scripts.</p>', 'Kevin Yank', '1020808800', '1');
INSERT INTO articles VALUES (2, 'Advanced email in PHP', 'I wish I could remember the very first email message I ever sent. Unfortunately, the truth is that I\'ve come to take email for granted; for instance, I easily send more email messages than I make phone calls. Because the novelty has long since worn off, the memory of that first email is as lost to me as my first phone call; but I doubt my sense of wonder was any less complete at the time. To someone who has never seen email in action before, that first message can be magical.', '<p>In this article, I\'ll try to recapture some of that magic for those of you who have never created a Web site that sends email messages. We\'ll see how the PHP server-side scripting language may be set up to send email, and explore how to send complex message types such as HTML email or emails with file attachments.</p>\r\n\r\n<h5>PHP Email Setup</h5>\r\n\r\n\r\n\r\n<p>Before we can send email with PHP, we need to set it up to do so, just as you need to set up your email program before it can send messages. Configuration for sending email in PHP is done with the <code>php.ini</code> file, so open up your Web server\'s <code>php.ini</code> in whichever editor you normally use.</p>\r\n\r\n<p>If you don\'t run your own server, but instead have a PHP-equipped Web host, you can safely assume that everything in this section has been done for you, and skip ahead.</p>\r\n\r\n<p>In the section entitled <code>[mail function]</code> in the <code>php.ini</code> file, you\'ll find three settings: <code>SMTP</code>, <code>sendmail_from</code>, and <code>sendmail_path</code>. If your server runs on a Windows machine, you\'ll want to set the <code>SMTP</code> option to point to your SMTP server (or your ISP\'s SMTP server, if you\'re setting up PHP on your home machine). If instead you\'re setting up PHP on a Linux (or other Unix-based OS) server, you\'ll want to set the <code>sendmail_path</code> option to point to the <code>sendmail</code> program on your server, passing it the <code>-t</code> option. You can use the SMTP option in Linux instead if you don\'t have <code>sendmail</code> set up.</p>\r\n\r\n<p>In either case, you\'ll want to set the <code>sendmail_from</code> option to your email address, or whichever address you\'d like to appear as the default \'from\' address for emails sent from PHP scripts.</p>\r\n\r\n<p>Here\'s how the section might look on a typical Windows server, or on a Linux server without sendmail:</p>\r\n\r\n<p><code>[mail function] <br />\r\n; Setup for Windows systems <br />\r\nSMTP = <em>smtp.my.isp.net</em> <br />\r\nsendmail_from = <em>me@myserver.com</em></code></p>\r\n\r\n<p>And here\'s how it might look on a Linux server with sendmail:</p>\r\n\r\n<p><code>[mail function] <br />\r\n; Setup for Linux systems <br />\r\nsendmail_path = /usr/sbin/sendmail -t <br />\r\nsendmail_from = me@myserver.com</code></p>\r\n\r\n<p>With those settings in place, restart your Web server and you\'re ready to go!</p>', 'Kevin Yank', '1013554800', '1');
INSERT INTO articles VALUES (4, 'eZ publish: PHP\'s Killer App', 'If you\'ve ever trawled the PHP listings over at Hotscripts in search of a content management system to save you from writing your own, you\'ve probably run into eZ publish, a PHP-based CMS application, and thought "Wow!" Jubilant, you tried to install it... to no avail. Desperately you tried reading the code, only to discover it made no sense whatsoever. Finally you skulked away to a quiet corner to lick your wounds, resorting to PHP Nuke instead.', '<p>This series is all about eZ publish and why it deserves the title of &quot;PHP\'s killer app&quot;. We\'ll start from the ground up: first, we\'ll install eZ publish in your development environment. Then, we\'ll learn how to make use of its features, and customise it to your specific needs. Finally, we\'ll take a look under the hood, to discover what makes eZ publish tick: how eZ publish is in fact a powerful tool to help you build your own Web-based applications.</p>\r\n\r\n<p>By the end, you\'ll be able not only to set up and customise your own eZ publish Website, but to build your own applications to run within eZ publish.</p>\r\n\r\n<p>Here\'s the lowdown...</p>\r\n\r\n<p><a class="sublink" href="http://webmasterbase.com/article/917/2">Part 1</a> - an introduction to eZ publish, where we explore, download, and install the required files.</p>\r\n\r\n<p><a class="sublink" href="http://webmasterbase.com/article/917/6">Part 2</a> - we get right into eZ publish, learning how to customize it to your requirements -- in terms of both looks, and functionality. We\'ll build our own small site and implement eZ article.</p>\r\n\r\n<p><a class="sublink" href="http://www.sitepoint.com/article/917/13">Part 3</a> - we discuss how you can create your own eZ publish module, taking a look under the hood to explore just how and why building your own modules is so simple with eZ publish.</p>\r\n\r\n<p>Let\'s get started!</p>\r\n\r\n\r\n\r\n<h5>Part 1</h5>\r\n\r\n\r\n\r\n<p>On the menu in this, the first article in the series, is:</p>\r\n\r\n<p><ol>\r\n	<li /><strong>Introducing eZ publish:</strong> the warm-up before we start on the real work</li><br />\r\n	<li /><strong>Installing eZ publish:</strong> get eZ publish up and running ready for article 2 in the series</li><br />\r\n	<li /><strong>Homework:</strong> tough discipline</li>\r\n</ol>\r\n</p>\r\n\r\n<h5>Introducing eZ publish</h5>\r\n\r\n\r\n\r\n<p>eZ publish is (on the surface) a Website content management system, written in <a rel=\'external\' class="sublink" href="http://www.php.net">PHP</a> by <a rel=\'external\' class="sublink" href="http://ez.no ">eZ systems</a>, a Norwegian company. Launched in 2000, eZ publish has come on in leaps and bounds, having been successfully put into action on sites like <a rel=\'external\' class="sublink" href="http://webservices.org/">Webservices.org</a>, the <a rel=\'external\' class="sublink" href="http://www.austria-tourism.at/">Austrian National Tourist Office</a> and <a rel=\'external\' class="sublink" href="http://www.symplicitynetworks.com/">Simplicity Networks</a> (more sites using eZ publish <a rel=\'external\' class="sublink" href="http://www.ez.no/developer/links/">here</a>), and gaining support from IBM and Siemens, among other <a rel=\'external\' class="sublink" href="http://shop.ez.no/partner/list/">business partners</a>. eZ publish is now even included in the <a rel=\'external\' class="sublink" href="http://developer.ez.no/article/view/358">Debian Linux distribution</a>.</p>\r\n\r\n<p>Content management systems, as you probably know from Kevin Yank\'s <a rel=\'external\' class="sublink" href="http://www.webmasterbase.com/article/228">famous tutorial</a>, allow you to publish dynamic content on your Website in manner that\'s easy to maintain and update. eZ publish takes that model close to perfection. Firstly, it allows you to store content in a database (eZ publish 2.x currently supports <a rel=\'external\' class="sublink" href="http://www.mysql.com">MySQL</a> and  <a rel=\'external\' class="sublink" href="http://www.postgresql.org">PostgreSQL</a>, with support for other databases like Oracle coming in version 3.x). On top of this database, a set of PHP applications provides a powerful administration interface for site maintenance, while a wealth of front end modules allow eZ publish to be rapidly implemented as anything from a news and community site like SitePoint or an online shop, to a B2B portal or even a corporate Intranet. In other words, it\'s the solution to all your Website needs!</p>\r\n\r\n<p>What\'s more, eZ publish already has a foot in the door of the <a rel=\'external\' class="sublink" href="http://www.webmasterbase.com/article/827">Web services</a> arena, with a commercially licensed <a rel=\'external\' class="sublink" href="http://shop.ez.no/trade/productview/25/2/">Desktop Edition</a> that allows you to update an eZ publish site using a C++ Windows client communicating with an XML-RPC server interface.</p>\r\n\r\n<p>Good news for paupers like me and you is eZ publish has a <a rel=\'external\' class="sublink" href="http://www.ez.no/article/articlestatic/222/1/30/">dual licensing scheme</a>. It provides both a <a rel=\'external\' class="sublink" href="http://www.gnu.org/copyleft/gpl.html1">GNU open source license</a>, and (for those wishing to do things like resell or rebrand eZ publish), a Professional license. For what is at heart an Open Source project, eZ systems are an excellent example of how to turn publicly-licensed software into a commercial success.</p>\r\n\r\n<p><em><strong>What\'s on Offer?</strong></em></p>\r\n\r\n<p>So, blurb aside, what does eZ publish actually have to offer? The easiest way to get answers is to visit the demo site at <a rel=\'external\' class="sublink" href="http://publishdemo.ez.no/">http://publishdemo.ez.no/</a>, and then login to the back end administration system by heading to <a rel=\'external\' class="sublink" href="http://admin.publishdemo.ez.no/">http://admin.publishdemo.ez.no/</a> using:</p>\r\n\r\n<p><strong>username: </strong>admin <br />\r\n<strong>password: </strong>publish </p>\r\n\r\n<p>Once you\'ve logged in, you\'ll see the demo site control panel with a row of icons along the top (time to have a play!). Each of these corresponds to an eZ publish <em>module,</em> which provides a range of functionalities for the front end of your Website.</p>\r\n\r\n<p>Among the modules you\'ll find:</p>\r\n\r\n<p><ul>\r\n	<li /><strong>eZ article:</strong> this the &quot;main&quot; module, allowing you to publish articles or &quot;static&quot; pages on your site</li>\r\n\r\n	<li /><strong>eZ trade:</strong> a powerful shopping cart application you\'ll find in action over at <a rel=\'external\' class="sublink" href="http://www.mygold.com/">MyGold</a>.com</li>\r\n\r\n	<li /><strong>eZ filemanager:</strong> a great tool for intranets and file distribution, providing an online filesystem for your visitors to browse</li>\r\n\r\n	<li /><strong>eZ forum:</strong> forums for your site, similar to (although not as powerful as) <a rel=\'external\' class="sublink" href="http://www.vbulletin.com/">VBulletin</a>, the software behind the <a rel=\'external\' class="sublink" href="http://www.sitepointforums.com">SitePoint Forums</a></li>\r\n</ul>\r\n</p>\r\n\r\n<p>...and many more that are described in detail in the <a rel=\'external\' class="sublink" href="http://doc.ez.no/article/archive/2/">User Manuals</a>. In other words, eZ publish gives you all you need to build your very own version of the SitePoint Network! You\'ll notice on both the <a rel=\'external\' class="sublink" href="http://publishdemo.ez.no/">demo site</a> and the <a rel=\'external\' class="sublink" href="http://developer.ez.no">main site</a> that even the URLs are similar to SitePoint\'s. For example:</p>\r\n\r\n<blockquote>http://developer.ez.no/article/articleview/367</blockquote>\r\n\r\n\r\n\r\n<p>and</p>\r\n\r\n<blockquote>http://www.webmasterbase.com/article/228</blockquote>\r\n\r\n\r\n\r\n<p>Of course there\'s a long way to go from building a site that works like SitePoint and convincing all the SitePoint fans to pay you a visit, but you get the point.</p>\r\n\r\n\r\n\r\n<p><em><strong>Yet another CMS?</strong></em></p>\r\n\r\n<p>&quot;OK&quot;, I hear you say, &quot;another content management system. Big deal.&quot;</p>\r\n\r\n<p>What makes eZ publish special is not the impressive list of features, but what\'s going on behind the scenes. eZ publish is in fact an application development framework, providing PHP developers with a structure in which to build applications and, from there, rapidly deploy them into a live environment, saving you many hours of coding.</p>\r\n\r\n<p>If you\'ve ever written you own PHP Website from scratch, you\'ve probably found yourself wishing there was an easier way to do things. You¡¦re confronted with a multitude of issues: where to place the scripts for your site, how to build an integrated site navigation system, how to prevent reproducing the same blocks of code for every page of your site¡K and a whole host of other problems (meanwhile, your social life packs up and heads to Hawaii).The long-awaited completion of a site can often feel like a miracle... then someone comes up with a great idea for some new features and you\'re re-writing the entire site again, weeping quietly to yourself.</p>\r\n\r\n<p>An application development framework eradicates the burdens of building Websites. By conforming to its rules and guidelines, you\'ll find the maintenance and expansion of your site a breeze. A good framework should make 90% of the design and development decisions for you. Solutions to issues such as naming conventions, where to place your scripts within your Website file system, how to design and structure your code, and all those other fine details you struggle with, are simply a matter of following a set of clear guidelines. And what about all that code you used to waste hours on, such as database connection and query functions, the work you reproduced over and over again for every new site? All that should be available within the framework for you to re-use as needed.</p>\r\n\r\n<p>This is what eZ publish really offers: the chance to make your life as a developer a carefree and pleasant one.</p>\r\n\r\n<p><em><strong>PHP Coder General\'s Warning:</strong></em></p>\r\n\r\n<p>Developing with eZ publish means writing Object Oriented code!</p>\r\n\r\n<p>Much as we all love to write &quot;hacked&quot; scripts using procedural code (perhaps with a few PHP functions included only when we <em>really</em> have to), the truth is, if you want to have any hair left a year or two from now, you <em>need</em> object orientation. Writing object oriented code in PHP is not just about saving time: it allows you to solve coding problems that simply cannot be solved by procedural code. Once you\'ve got two or three PHP classes working together in an application, you\'ll realise you never want to go back. And then you\'ll be able to hack away like you\'ve never hacked before!</p>\r\n\r\n<p>Put another way, object orientation give us the means to write re-usable code and integrate different applications and functionality into a single whole. For example, you may already have run into difficulties on one of your sites, where you implemented a user authentication system and signed loads of people up. You\'re now scratching your head as to how to integrate it with a forum application like <a rel=\'external\' class="sublink" href="http://www.vbulletin.com">VBulletin</a> or <a rel=\'external\' class="sublink" href="http://www.phpbb.com">phpBB</a> without forcing your users to sign up again. If we all wrote more object oriented code, at least half these problems would be solved.</p>\r\n\r\n<p>In general, the way eZ publish functions in tying together its various modules, is conceptually similar to the <a rel=\'external\' class="sublink" href="http://www.fusebox.org/">Fusebox</a> approach. This strategy for building Web applications was conceived by developers working with Coldfusion, and has now made its way to PHP at <a rel=\'external\' class="sublink" href="http://bombusbee.com/">Bombusbee.com</a>. The basic concept behind a fusebox-like site is to have a single script (usually index.php in the Web root) that acts as &quot;traffic cop&quot; for the site, all pages being served &quot;through&quot; index.php. For further details on the Fusebox approach, try the <a rel=\'external\' class="sublink" href="http://bombusbee.com/downloads/files/FuseboxNewbieGuideV3PHP.pdf">Fusebox Newbie Guide</a>. From an application design perspective, eZ publish loosely conforms to the Fusebox approach, so it may help to read about Fuseboxes in preparation for the third article in this series. But don\'t panic! We\'ll leave further discussion of object orientation and application design until the third article in this series. </p>\r\n\r\n<p>Back to eZ publish! To whet the appetite of those who know your way around PHP classes, have a look at the eZ publish <a rel=\'external\' class="sublink" href="http://developer.ez.no/doc/view/index">Class Index</a>. Then wander over to the <a rel=\'external\' class="sublink" href="http://sdk.ez.no">eZ publish sdk</a> currently in development for eZ publish v.3.</p>\r\n\r\n<p>Hopefully by now you\'re at least sold on the idea that eZ publish is worth your effort. In that case, it\'s time to roll up our sleeves and get installing! eZ publish, here we come.</p>\r\n\r\n<h5>Installing eZ publish</h5>\r\n\r\n\r\n\r\n<p>In setting up a working version of eZ publish, I\'ll dare to assume you use Windows and are willing to set up a demo on your own machine. The installation process used here can very easily be applied to a LAMP (Linux, Apache, MySQL, PHP) virtual host environment common to many Web hosts.</p>\r\n\r\n<p>It\'s recommended you have at least PHP version 4.0.6 installed (even better if it\'s PHP 4.1+) under Apache 1.3x as well as MySQL 3.23 or later. If you don\'t have those installed, look no further than <a rel=\'external\' class="sublink" href="http://www.firepages.com.au">Firepage\'s</a> phpdev, an install set that gives you Apache, PHP and MySQL in one tidy package (plus a few other nice things like <a rel=\'external\' class="sublink" href="http://www.webmasterbase.com/article/839">PHP-GTK</a> and <a rel=\'external\' class="sublink" href="http://www.phpmyadmin.org/">phpMyAdmin</a>). The current phpdev5 beta3 is very stable but to save yourself some headaches, it\'s recommended you use Apache 1.3.x rather than 2.x (phpdev5 beta 3 comes with both).</p>\r\n\r\n<p>The version of eZ publish used in this article series is 2.2.6. The install process may vary for different versions, and be aware that eZ publish is <em>very</em> sensitive to the correct php.ini settings. If you have any problems with the instructions used in this article, please drop your questions in the <a rel=\'external\' class="sublink" href="http://www.sitepointforums.com">SitePoint Forums</a> discussion at the end of this article. Otherwise, you\'ll find plenty of people willing to help at <a rel=\'external\' class="sublink" href="http://developer.ez.no/developer/forums/">http://developer.ez.no/developer/forums/</a>.</p>', 'Harry Fuecks', '1036450800', '0');

